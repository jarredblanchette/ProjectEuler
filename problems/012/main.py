# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?
import math
def sieve(primes, numbers_to_sieve):
    """Sieves out the non-prime numbers
        :param primes: A set of known primes to act as a seed
        :param numbers_to_sieve: the set of numbers we're going to filter.  If primes and numbers_to_sieve abut, we are gauranteed to have only primes in numbers_to_sieve
        :returns list of prime numbers and the prime numbers in the numbers_to_sieve"""
    numbers_to_sieve = list(numbers_to_sieve)

    # my kingdom for the filter method to work on filter objects.
    for prime in primes + numbers_to_sieve:
        if prime > max(primes + numbers_to_sieve) / 2 or len(numbers_to_sieve) == 0:
            break
        numbers_to_sieve = list(filter(lambda x: x % prime != 0 or x == prime, numbers_to_sieve))

    return primes, numbers_to_sieve


def get_factor_dict(n, primes=None):
    """calculates the prime factors, expressed in the
    :param n is the number we wish to factorise
    :param primes optional,
    :returns a dict where the keys are prime factors, and the values are the number of times the prime goes into n"""
    if primes is None:
        primes, sieved = sieve([2, 3, 5], list(range(6, int(math.sqrt(n)))))
        primes = primes + sieved
    elif max(primes) < math.floor(math.sqrt(n)):
        primes, sieved = sieve(primes, list(range(max(primes) +1 , math.ceil(math.sqrt(n)))))
        primes = primes + sieved

    res = dict({})
    for factor in primes:
        while n % factor == 0:
            res[factor] = res.get(factor, 0) + 1
            n /= factor
        if n == 1:
            break

    return res, primes


def get_factor_count(factor_dict):
    acc = 1
    for value in factor_dict.values():
        acc *= value + 1
    return acc


def get_next_triangle(current_triangle, current_index):
    current_triangle += current_index
    current_index += 1
    return current_triangle, current_index


if __name__ == '__main__':
    current_triangle, index = 1, 2

    primes = [2, 3, 5, 7]
    current_triangle, index = get_next_triangle(current_triangle, index)
    factors, primes = get_factor_dict(current_triangle, primes)

    # fairly naive solution,
    # alternative is to find minimum powers of our prime factors ST there's >500 factors
    # and use this factor minimum to combine primes to find the minimum triangular number.
    while get_factor_count(factors) < 500:
        current_triangle, index = get_next_triangle(current_triangle, index)
        factors, primes = get_factor_dict(current_triangle, primes)

    print(current_triangle,get_factor_count(factors),factors)
